/*
 * deploy
 */

//APPPATH.config/development/db.php 

データベース接続情報を設定する

//oil

php oil refine migrate:up --modules=acl
php oil refine migrate:up --modules=user
php oil refine migrate:up --modules=usergroup
php oil refine migrate:up --modules=users_usergroups_r
php oil refine migrate:up --modules=loginlog
php oil refine migrate:up --modules=workflowadmin
php oil refine migrate:up --modules=revision

//APPPATH.config/config.php

- always_loadに、kontikiをたす

- Security settingsのコメントアウトを外して、以下のように設定する

		 'csrf_autoload'    => false,
		 'csrf_token_key'   => 'kontiki_csrf_token',
		 'csrf_expiration'  => 300,

//APPPATH.config/routes.php

- トップページと404を変更
	'_root_'  => 'content/home',
	'_404_'   => 'content/404',

/*
 * Development
 */

Kontikiパッケージ（以下kontiki）はfuelphpのmoduleを基礎にしています。

kontikiを用いて構築する際は、原則PKGPATH.'kontiki/modules/'以下に、以下のような構成のファイルをおいてください。kontikiのscaffoldを使うと簡単に生成できます。

MODNAME
- classes
	- controller
		- MODNAME.php
	- model
		- MODNAME.php
	- view
		- MODNAME.php
- migrations
- config
	- MODNAME.php
- views

ただし、コントローラをコンパクトに書くための独自ルーティングがあります。
modules/MODNAME/classes/controller/MODNAME_ACTNAME.phpで、1ファイルに1つのアクションを独立して書くことができます。この際、継承するclassは適宜気をつけてください。ほとんどの場合は、\kontiki\controllerでなく、MODNAMEにあたるclassを継承することになるはずです。

kontikiには、基本的なcrudを実装した基礎classがあります。この基礎classは、fuelのclassを継承していますが、必ず使わなくていけないということはありません。必要に応じてfuelのclassを直に継承して問題はありません。

/*
 * revision（編集履歴）
 */

kontikiのscaffoldを利用している場合は、コントローラの

unset( self::$actionset->view_revision );

をコメントアウト（あるいは削除すると）、コントローラでの編集履歴が有効になります。
編集履歴は、action_edit()と依存関係にあるので、action_edit()以外の編集方法を用いている場合は、うまく動作しません。
あと任意ですが、対象コントローラの編集画面に下記フォームを足すと、コメントとして保存されます。

<div class="form-group revision_comment">
	<?php echo Form::label('編集メモ', 'revision_comment')); ?>
	<?php echo Form::textarea('revision_comment', Input::post('revision_comment', isset($item->comment) ? $item->comment : '')); ?>
</div>

/*
 * ワークフロー管理
 */

ワークフロー管理をするためには、kontikiのscaffoldで出来上がったset_actionsetのWorkflow関連部分のコメントアウトを外してください。あとclass宣言部分のextendsもとを\Kontiki\Controller_Workflowに差し替えてください。
対象モデルの$_propertiesにworkflow_statusを足します。

/*
 * オプション
 */

モジュール内でユーザが編集できるオプション項目をcrudするコントローラを使いたいときには、以下の手順で作成してください。おおまかには、
1. migrationの作成
2. actionsetの作成
3. テーブル構造にあわせてtemplateを用意する
4. コントローラに実装する
という流れです。

1、モジュールのmigrationsフォルダに、マイグレーション用のファイルを置き、oilでmigrationします。
オプション用のtable名は自由ですが、中間テーブルの名前はオプション用のtable名に_rの接尾辞をつけるようにしてください。
また、オプション用のtableには、id, name, order, is_availableは、使わなくても必須です。これにほかのカラムを追加して使うこともできます。

例）
postモジュールにオプションを足します。
migrationは、002_create_postcategories.phpとします。
ファイルを設置したら、
php oil refine migrate:up --modules=post
で、migrationします。

▼ここから────────────────
<?php
namespace Fuel\Migrations;
class Create_postcategories
{
	public function up()
	{
		\DBUtil::create_table('postcategories', array(
			'id'           => array('constraint' => 11, 'type' => 'int', 'auto_increment' => true, 'unsigned' => true),
			'name'         => array('constraint' => 50, 'type' => 'varchar'),
			'order'        => array('constraint' => 11, 'type' => 'int', 'unsigned' => true),
			'is_available' => array('constraint' => 1, 'type' => 'tinyint'),
		), array('id'));
		
		\DBUtil::create_table('postcategories_r', array(
			'item_id'   => array('constraint' => 11, 'type' => 'int', 'unsigned' => true),
			'option_id' => array('constraint' => 11, 'type' => 'int', 'unsigned' => true),
		), array('item_id','option_id'));
	}

	public function down()
	{
		\DBUtil::drop_table('postcategories');
		\DBUtil::drop_table('postcategories_r');
	}
}
────────────────ここまで▲

2、モジュールのactionset.phpに、オプション用のアクションセットを設定します。

例）
postモジュールにpostcategoriesを足す場合です。

▼ここから────────────────
<?php
namespace Post;
class Actionset_Post extends \Kontiki\Actionset
{
	/**
	 * actionItems()
	 * @return  obj
	 */
	public static function actionItems($controller = null, $item = null)
	{
		$actions = parent::actionItems($controller, $item);
		//postcategoriesの部分は任意の文字列ですが、table名にしておくのがよいです。
		$actions->postcategories = self::postcategories($controller, $item);
		return $actions;
	}

	/**
	 * postcategories()
	 * @return  array
	 */
	private static function postcategories($controller, $item)
	{
		$url = parent::check_auth($controller, 'postcategories') ? "{$controller}/options/postcategories" : '';
		$url_rev = $url ? "{$controller}/options_revisions/postcategories" : '';
		$urls = array(
			array('カテゴリ設定', $url),
			array('カテゴリ設定履歴', $url_rev),
		);

		$retvals = array(
			'is_admin_only' => false,
			'is_index'      => true,
			'url'           => $urls,
			'id_segment'    => null,
			'action_name'   => 'カテゴリ',
			'explanation'   => 'postコントローラのカテゴリです。',
			'menu_str'      => '',
			'dependencies' => array(
				'options/postcategories',
			)
		);
		return $retvals;
	}
}
────────────────ここまで▲

3、当該モジュールに編集用テンプレートを用意します。テンプレート名は、options_テーブル名.phpです。scaffoldで作られるoptions_samples.phpをもとにtable構造にあわせて編集してください。

4、テンプレートとコントローラに実装します。nameは、table名かtable名の配列にしてください。

例）テンプレートへの実装
▼ここから────────────────
<?php
foreach(\Post\Model_Post::get_options('postcategories') as $key => $option):
	$checked = false; 
	if(
		(isset($item) && in_array($key, $item->postcategories)) ||
		(is_array(\Input::post('postcategories')) && array_key_exists($key, \Input::post('postcategories')))
	):
		$checked = true; 
	endif;
	echo '<label>'.\Form::checkbox('postcategories[]', $key, $checked ).$option.'</label>';
endforeach;
?>
────────────────ここまで▲

コントローラは、post_save_hook()で保存時フックする。

▼ここから────────────────
	/**
	 * post_save_hook()
	 */
	public function post_save_hook($obj = null, $mode = 'edit')
	{
		if($obj == null) \Response::redirect($this->request->module);
		$obj = parent::post_save_hook($obj, $mode);

		//postcategories
		$model = $this->model_name;
		$model::update_options_relations('postcategories', $obj->id);

		return $obj;
	}
────────────────ここまで▲

加えて、コントローラのmodify_array()を編集すると、オプションの値がリビジョンに保存される。以下例はarray()だが、array()でない場合は適宜変更する

▼ここから────────────────
	/**
	 * modify_array()
	 */
	public function modify_array($obj, $mode = null)
	{
		if($mode == 'insert_revision'):
			$postcategories = is_array(\Input::post('postcategories')) ? \Input::post('postcategories') : array();
			$obj->postcategories = $postcategories;
		endif;
		return $obj;
	}
────────────────ここまで▲

モデルはfind_item()をオーバライドする

▼ここから────────────────
	/**
	 * find_item()
	 */
	public static function find_item($id = null)
	{
		//parent
		$item = parent::find_item($id);

		//オプションの取得
		if($item):
			$item->postcategories = \Post\Model_Post::get_selected_options('postcategories', $id);
		endif;

		return $item;
	}
────────────────ここまで▲

以上でオプションの値が保存される。

